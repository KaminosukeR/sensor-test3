<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>ã‚¹ãƒãƒ›ã‚»ãƒ³ã‚µãƒ¼è¨ˆæ¸¬ï¼ˆç²—è¡¨ç¤ºç‰ˆï¼‰</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: sans-serif; margin: 10px; background: #f7f7f7; color: #111; }
    header { text-align: center; margin-bottom: 8px; }
    button { margin: 6px; padding: 8px 14px; font-size: 15px; }
    .chart-wrap { max-width: 980px; margin: 8px auto; }
    canvas { background: #fff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); }
    footer { text-align:center; margin-top:12px; font-size:13px; color:#555; }
  </style>
</head>
<body>
  <header>
    <h2>ğŸ“± ã‚¹ãƒãƒ›ã‚»ãƒ³ã‚µãƒ¼è¨ˆæ¸¬ï¼ˆ0.1sé›†è¨ˆãƒ»å°æ•°ç‚¹2æ¡è¡¨ç¤ºï¼‰</h2>
    <p>ãƒ‡ãƒ¼ã‚¿ã¯ raw ã«è¨˜éŒ²ã€‚ã‚°ãƒ©ãƒ•ã¯ 0.1 ç§’å˜ä½ã§å¹³å‡åŒ–ã—ã¦è¡¨ç¤ºã—ã¾ã™ã€‚</p>
    <div>
      <button id="startBtn">è¨ˆæ¸¬é–‹å§‹</button>
      <button id="stopBtn" disabled>åœæ­¢</button>
      <button id="saveBtn" disabled>CSV ä¿å­˜ï¼ˆè¡¨ç¤ºå€¤ï¼‰</button>
    </div>
  </header>

  <div class="chart-wrap">
    <canvas id="accChart" height="160"></canvas>
  </div>
  <div class="chart-wrap">
    <canvas id="rotChart" height="160"></canvas>
  </div>

  <footer>
    è¡¨ç¤ºã¯0.1ç§’å˜ä½ã«é›†è¨ˆãƒ»å°æ•°ç‚¹2æ¡ã«ä¸¸ã‚ã¦ã„ã¾ã™ã€‚CSVã¯è¡¨ç¤ºå€¤ã§ä¿å­˜ã•ã‚Œã¾ã™ï¼ˆå¿…è¦ãªã‚‰rawä¿å­˜ã«åˆ‡æ›¿å¯èƒ½ï¼‰ã€‚
  </footer>

<script>
/* ===== è¨­è¨ˆ =====
 - rawLog: å…¨ã‚»ãƒ³ã‚µãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã‚’ãã®ã¾ã¾ä¿å­˜ï¼ˆæ°¸ç¶šCSVå‡ºåŠ›ã‚„å¾Œå‡¦ç†ç”¨ï¼‰
 - bucket aggregation: 100msé–“éš”ã§åé›†ã—å¹³å‡ã‚’ãƒãƒ£ãƒ¼ãƒˆã¸è¿½åŠ 
 - display rounding: å°æ•°ç‚¹2æ¡ã§è¡¨ç¤º/ä¿å­˜
 - MAX_POINTS: ãƒãƒ£ãƒ¼ãƒˆå†…ã®æœ€å¤§ç‚¹æ•°ï¼ˆå¤ã„ã‚‚ã®ã‚’å‰Šé™¤ï¼‰
*/

const AGG_MS = 100;       // 0.1ç§’ã”ã¨ã«è¡¨ç¤ºç”¨ã«å¹³å‡åŒ–
const MAX_POINTS = 300;   // ã‚°ãƒ©ãƒ•ã«ä¿æŒã™ã‚‹ç‚¹æ•°ï¼ˆèª¿æ•´å¯ï¼‰
let rawLog = [];          // ãƒ•ãƒ«ç²¾åº¦ã§ä¿å­˜
let aggBuffer = [];       // ç¾åœ¨ã®ãƒã‚±ãƒƒãƒˆã«å…¥ã‚Œã¦å¹³å‡åŒ–ã™ã‚‹ãŸã‚ã®ä¸€æ™‚é…åˆ—
let lastBucketTime = 0;
let aggTimer = null;

let accChart, rotChart;
const accCtx = document.getElementById("accChart").getContext("2d");
const rotCtx = document.getElementById("rotChart").getContext("2d");

const accData = {
  labels: [],
  datasets: [
    { label: 'Acc X (m/sÂ²)', data: [], borderColor: 'rgba(220,53,69,1)', tension:0.2, pointRadius:0 },
    { label: 'Acc Y (m/sÂ²)', data: [], borderColor: 'rgba(25,135,84,1)', tension:0.2, pointRadius:0 },
    { label: 'Acc Z (m/sÂ²)', data: [], borderColor: 'rgba(13,110,253,1)', tension:0.2, pointRadius:0 }
  ]
};

const rotData = {
  labels: [],
  datasets: [
    { label: 'rot Î± (deg/s)', data: [], borderColor: 'rgba(102,16,242,1)', tension:0.2, pointRadius:0 },
    { label: 'rot Î² (deg/s)', data: [], borderColor: 'rgba(255,159,67,1)', tension:0.2, pointRadius:0 },
    { label: 'rot Î³ (deg/s)', data: [], borderColor: 'rgba(108,117,125,1)', tension:0.2, pointRadius:0 }
  ]
};

accChart = new Chart(accCtx, {
  type: 'line',
  data: accData,
  options: { animation:false, plugins:{legend:{position:'top'}}, scales:{ x:{display:true}, y:{display:true} } }
});
rotChart = new Chart(rotCtx, {
  type: 'line',
  data: rotData,
  options: { animation:false, plugins:{legend:{position:'top'}}, scales:{ x:{display:true}, y:{display:true} } }
});

// ãƒœã‚¿ãƒ³
const startBtn = document.getElementById("startBtn");
const stopBtn  = document.getElementById("stopBtn");
const saveBtn  = document.getElementById("saveBtn");

startBtn.onclick = async () => {
  // iOSç­‰ã§ã¯æ¨©é™ãŒå¿…è¦
  if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
    try {
      const resp = await DeviceMotionEvent.requestPermission();
      if (resp !== 'granted') { alert('ã‚»ãƒ³ã‚µãƒ¼æ¨©é™ãŒå¿…è¦ã§ã™'); return; }
    } catch(e){ alert('ã‚»ãƒ³ã‚µãƒ¼æ¨©é™ã®è¦æ±‚ã«å¤±æ•—ã—ã¾ã—ãŸ'); return; }
  }
  startRecording();
};
stopBtn.onclick = stopRecording;
saveBtn.onclick = () => { saveCSV(false); }; // false => è¡¨ç¤ºå€¤ã§ä¿å­˜ï¼ˆä¸¸ã‚ï¼‰

// è¨˜éŒ²ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
let recording = false;
function startRecording(){
  recording = true;
  rawLog = [];
  aggBuffer = [];
  lastBucketTime = Math.floor(Date.now() / AGG_MS) * AGG_MS;
  // ãƒãƒ£ãƒ¼ãƒˆã®åˆæœŸåŒ–
  accData.labels = []; accData.datasets.forEach(ds => ds.data = []);
  rotData.labels = []; rotData.datasets.forEach(ds => ds.data = []);
  accChart.update(); rotChart.update();
  startBtn.disabled = true;
  stopBtn.disabled = false;
  saveBtn.disabled = true;

  window.addEventListener('devicemotion', onMotion, { passive: true });
  // ãƒã‚±ãƒƒãƒˆãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚¿ã‚¤ãƒãƒ¼ï¼ˆä¿é™ºï¼‰
  aggTimer = setInterval(() => flushBucketIfNeeded(), AGG_MS + 20);
}

function stopRecording(){
  recording = false;
  window.removeEventListener('devicemotion', onMotion);
  if (aggTimer) { clearInterval(aggTimer); aggTimer = null; }
  // æœ€å¾Œã®ãƒã‚±ãƒƒãƒˆã‚’ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
  flushBucket(true);
  startBtn.disabled = false;
  stopBtn.disabled = true;
  saveBtn.disabled = false;
}

// ã‚»ãƒ³ã‚µãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆå—ã‘å–ã‚Šï¼ˆé«˜é »åº¦ï¼‰ -> rawLog ã¨ aggBuffer ã«è²¯ã‚ã‚‹
function onMotion(e){
  const t = Date.now();
  const acc = e.accelerationIncludingGravity || e.acceleration || { x:0,y:0,z:0 };
  const rot = e.rotationRate || { alpha:0,beta:0,gamma:0 };
  const entry = {
    t,
    accX: acc.x || 0,
    accY: acc.y || 0,
    accZ: acc.z || 0,
    rotA: rot.alpha || 0,
    rotB: rot.beta || 0,
    rotG: rot.gamma || 0
  };
  rawLog.push(entry);
  // ãƒã‚±ãƒƒãƒˆåˆ¤å®š
  const bucketKey = Math.floor(t / AGG_MS) * AGG_MS;
  if (bucketKey !== lastBucketTime) {
    // ãƒã‚±ãƒƒãƒˆåˆ‡æ›¿ï¼šå¤ã„ãƒã‚±ãƒƒãƒˆã‚’åã
    flushBucket();
    lastBucketTime = bucketKey;
  }
  aggBuffer.push(entry);
}

// ãƒã‚±ãƒƒãƒˆï¼ˆ0.1sï¼‰å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’å¹³å‡åŒ–ã—ã¦ãƒãƒ£ãƒ¼ãƒˆã¸è¿½åŠ 
function flushBucket(force=false){
  if (aggBuffer.length === 0 && !force) return;
  if (aggBuffer.length === 0 && force) return;

  // å¹³å‡ã‚’è¨ˆç®—
  const n = aggBuffer.length;
  const sum = aggBuffer.reduce((s, d) => {
    s.accX += d.accX; s.accY += d.accY; s.accZ += d.accZ;
    s.rotA += d.rotA; s.rotB += d.rotB; s.rotG += d.rotG;
    return s;
  }, {accX:0,accY:0,accZ:0,rotA:0,rotB:0,rotG:0});

  const avg = {
    accX: sum.accX / n,
    accY: sum.accY / n,
    accZ: sum.accZ / n,
    rotA: sum.rotA / n,
    rotB: sum.rotB / n,
    rotG: sum.rotG / n,
    // label: æ™‚åˆ»ï¼ˆHH:MM:SS.sï¼‰
    label: new Date(lastBucketTime).toLocaleTimeString() + '.' + String(Math.floor((lastBucketTime % 1000)/100))
  };

  // è¡¨ç¤ºç”¨ã«å°æ•°ç‚¹2æ¡ã«ä¸¸ã‚ã‚‹
  const round2 = v => Math.round(v * 100) / 100;

  // ãƒ©ãƒ™ãƒ«ã¨ãƒ‡ãƒ¼ã‚¿è¿½åŠ ï¼ˆæœ€æ–°MAX_POINTSã®ã¿ä¿æŒï¼‰
  accData.labels.push(avg.label);
  accData.datasets[0].data.push(round2(avg.accX));
  accData.datasets[1].data.push(round2(avg.accY));
  accData.datasets[2].data.push(round2(avg.accZ));
  rotData.labels.push(avg.label);
  rotData.datasets[0].data.push(round2(avg.rotA));
  rotData.datasets[1].data.push(round2(avg.rotB));
  rotData.datasets[2].data.push(round2(avg.rotG));

  // å¤ã„ç‚¹ã‚’å‰Šã‚‹
  while (accData.labels.length > MAX_POINTS) {
    accData.labels.shift();
    accData.datasets.forEach(ds => ds.data.shift());
    rotData.labels.shift();
    rotData.datasets.forEach(ds => ds.data.shift());
  }

  // ãƒãƒ£ãƒ¼ãƒˆæ›´æ–°ï¼ˆæ¯ãƒã‚±ãƒƒãƒˆæ›´æ–°ã—ã¦ã‚‚è² è·ä½ï¼‰
  accChart.update();
  rotChart.update();

  // ãƒãƒƒãƒ•ã‚¡ã‚¯ãƒªã‚¢
  aggBuffer = [];
}

// å¿µã®ãŸã‚ã®ãƒ•ãƒ©ãƒƒã‚·ãƒ¥åˆ¤å®šï¼ˆã‚¿ã‚¤ãƒãƒ¼ã‹ã‚‰å‘¼ã¶ï¼‰
function flushBucketIfNeeded(){
  const nowKey = Math.floor(Date.now() / AGG_MS) * AGG_MS;
  if (nowKey !== lastBucketTime) {
    // æ™‚é–“ãŒé€²ã‚“ã§ã„ã‚Œã°ä»Šã®ãƒã‚±ãƒƒãƒˆã‚’ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
    flushBucket();
    lastBucketTime = nowKey;
  }
}

// CSV ä¿å­˜ï¼ˆè¡¨ç¤ºå€¤ã‚’ä¿å­˜ï¼‰ã€‚raw=true ã«ã™ã‚‹ã¨ rawLog ã‚’ä¿å­˜ã§ãã¾ã™ã€‚
function saveCSV(raw=false){
  let csv = [];
  if (raw) {
    csv.push('time(ms),accX,accY,accZ,rotA,rotB,rotG');
    rawLog.forEach(d => {
      csv.push(`${d.t},${d.accX},${d.accY},${d.accZ},${d.rotA},${d.rotB},${d.rotG}`);
    });
  } else {
    // è¡¨ç¤ºä¸­ã®ä¸¸ã‚ã‚‰ã‚ŒãŸç‚¹ã‚’ä¿å­˜ï¼ˆæ™‚åˆ»ãƒ©ãƒ™ãƒ«ã¯ lastBucketTime label è¡¨ç¤ºï¼‰
    csv.push('label,accX,accY,accZ,rotA,rotB,rotG');
    for (let i=0;i<accData.labels.length;i++){
      const label = accData.labels[i];
      const ax = accData.datasets[0].data[i];
      const ay = accData.datasets[1].data[i];
      const az = accData.datasets[2].data[i];
      const ra = rotData.datasets[0].data[i];
      const rb = rotData.datasets[1].data[i];
      const rg = rotData.datasets[2].data[i];
      csv.push(`${label},${ax},${ay},${az},${ra},${rb},${rg}`);
    }
  }
  const blob = new Blob([csv.join('\n')], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = raw ? 'sensor_raw.csv' : 'sensor_rounded.csv';
  a.click();
}

</script>
</body>
</html>
